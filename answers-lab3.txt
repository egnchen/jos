> Q1: What is the purpose of having an individual handler function for each exception/interrupt?
> (i.e., if all exceptions/interrupts were delivered to the same handler, what feature that exists in the current implementation could not be provided?)

If all exception & interrupts are forwarded to a single individual handler then there's no way to determine which interrupt/exception we're dealing with, unless the hardware explicitly push the error number onto the stack.

> Did you have to do anything to make the user/softint program behave correctly?
> The grade script expects it to produce a general protection fault (trap 13), but softint's code says int $14. Why should this produce interrupt vector 13? 
> What happens if the kernel actually allows softint's int $14 instruction to invoke the kernel's page fault handler (which is interrupt vector 14)?

Actually no. user/softint produces a PGFAULT which is not allowed to be sent explicitly by `int` instruction under user mode, so a *general protection fault* is sent instead. If we do allow user program to invoke kernel's page fault handler this could cause significant security issues.

> The break point test case will either generate a break point exception or a general protection fault depending on how you initialized the break point entry in the IDT (i.e., your call to SETGATE from trap_init). Why?
> How do you need to set it up in order to get the breakpoint exception to work as specified above and what incorrect setup would cause it to trigger a general protection fault?

The last argument in SETGATE macro(dpl) sets the minimum priviledge level to invoke this exception explicitly. If dpl is set to 3 then user space invocation is allowed, otherwise a GPF is produced.

To set it up just change *dpl* to *0* in breakpoint fault's SETGATE.

> What do you think is the point of these mechanisms, particularly in light of what the user/softint test program does?

For the sake of security.